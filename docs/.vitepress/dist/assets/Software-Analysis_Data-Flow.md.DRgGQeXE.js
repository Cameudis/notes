import{_ as a,c as t,o as e,a4 as o}from"./chunks/framework.DZjHTG0m.js";const g=JSON.parse('{"title":"数据流分析","description":"","frontmatter":{},"headers":[],"relativePath":"Software-Analysis/Data-Flow.md","filePath":"Software-Analysis/Data-Flow.md"}'),i={name:"Software-Analysis/Data-Flow.md"},r=o('<h1 id="数据流分析" tabindex="-1">数据流分析 <a class="header-anchor" href="#数据流分析" aria-label="Permalink to &quot;数据流分析&quot;">​</a></h1><p>一个程序可以以看成是状态（数据）和状态之间的转移（控制）两部分（就像路由系统的 data plane 以及 control plane）。在静态分析程序时，我们很难知道状态会如何转移，因此可以在分析时直接忽略状态转移的条件，认为所有的分支都有可能到达，只关注数据的变化。这种做法就叫做<strong>数据流分析</strong>。</p><p>我们暂时不考虑分析的目标，只考虑数据流分析的算法。比如 Liveliness Analysis 就属于数据流分析的算法。此类算法具有一些共同的特质，比如都是不断循环直到某轮的状态不再更新时停止。我们重点关注数据流分析如何处理条件分支和循环语句。</p><ul><li>近似方案1：忽略掉程序的条件判断，认为所有分支都有可能到达</li><li>近似方案2：不在路径末尾做合并，在控制流汇合的所有位置提前做合并</li></ul><p>因此，我们会在算法中一视同仁地处理两个分支，处理它们的结点，并在每轮中不断对每个结点做交汇运算来更新其值，直到没有任何结点的值发生更新。</p><p>对于此类算法，其安全性、终止性和收敛性都可以使用一套名为<strong>数据流分析单调框架</strong>的数学模型进行证明。这个模型设计到的数据较为复杂，具体请参考相关资料。</p><p>大量的静态分析可以通过一种叫做 Datalog 的逻辑语言来简洁地实现，有许多不同的 Datalog 引擎的实现，详见 <a href="https://en.wikipedia.org/wiki/Datalog" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Datalog</a>。</p><hr><p>参考资料：<a href="https://xiongyingfei.github.io/SA/2022/03_dataflow_analysis_I.pdf" target="_blank" rel="noreferrer">https://xiongyingfei.github.io/SA/2022/03_dataflow_analysis_I.pdf</a></p>',9),n=[r];function s(l,_,p,d,c,f){return e(),t("div",null,n)}const w=a(i,[["render",s]]);export{g as __pageData,w as default};
