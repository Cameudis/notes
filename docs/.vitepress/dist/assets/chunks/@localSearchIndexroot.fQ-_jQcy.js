const t='{"documentCount":19,"nextId":19,"documentIds":{"0":"/notes/Algorithm/Analysis.html#时间复杂度","1":"/notes/Algorithm/Analysis.html#渐进分析的几种标记","2":"/notes/Algorithm/Analysis.html#大-o-表示法","3":"/notes/Algorithm/Analysis.html#大-ω-表示法","4":"/notes/Algorithm/Analysis.html#大-θ-表示法","5":"/notes/Algorithm/Analysis.html#计算递归函数的时间消耗","6":"/notes/Algorithm/Analysis.html#使用迭代法猜测复杂度","7":"/notes/Algorithm/Analysis.html#使用代入法证明猜测","8":"/notes/Algorithm/Analysis.html#使用-master-theorem-秒杀递归函数","9":"/notes/Algorithm/Analysis.html#摊还分析","10":"/notes/Algorithm/Analysis.html#摊还分析的三种方法","11":"/notes/Software-Analysis/Introduction.html#软件分析","12":"/notes/Software-Analysis/Introduction.html#非判定问题","13":"/notes/Software-Analysis/Data-Flow.html#数据流分析","14":"/notes/Fuzzing/Fuzzing-Basic.html#fuzzing-基础","15":"/notes/Fuzzing/Fuzzing-Basic.html#coverage","16":"/notes/Fuzzing/Fuzzing-Basic.html#mutation-based-fuzzing","17":"/notes/Software-Analysis/SSA.html#静态单赋值和稀疏分析","18":"/notes/Software-Analysis/SSA.html#ssa-转换"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,15],"1":[1,1,1],"2":[5,2,14],"3":[5,2,14],"4":[5,2,27],"5":[1,1,14],"6":[1,2,23],"7":[1,2,18],"8":[4,2,42],"9":[1,1,12],"10":[1,1,37],"11":[1,1,50],"12":[1,1,34],"13":[1,1,64],"14":[2,1,33],"15":[1,2,48],"16":[3,2,1],"17":[1,1,25],"18":[2,1,47]},"averageFieldLength":[2,1.4210526315789473,27.31578947368421],"storedFields":{"0":{"title":"时间复杂度","titles":[]},"1":{"title":"渐进分析的几种标记","titles":["时间复杂度"]},"2":{"title":"大 O 表示法 O(n)","titles":["时间复杂度","渐进分析的几种标记"]},"3":{"title":"大 Ω 表示法 Ω(n)","titles":["时间复杂度","渐进分析的几种标记"]},"4":{"title":"大 Θ 表示法 Θ(n)","titles":["时间复杂度","渐进分析的几种标记"]},"5":{"title":"计算递归函数的时间消耗","titles":["时间复杂度"]},"6":{"title":"使用迭代法猜测复杂度","titles":["时间复杂度","计算递归函数的时间消耗"]},"7":{"title":"使用代入法证明猜测","titles":["时间复杂度","计算递归函数的时间消耗"]},"8":{"title":"使用 Master Theorem 秒杀递归函数","titles":["时间复杂度","计算递归函数的时间消耗"]},"9":{"title":"摊还分析","titles":["时间复杂度"]},"10":{"title":"摊还分析的三种方法","titles":["时间复杂度"]},"11":{"title":"软件分析","titles":[]},"12":{"title":"非判定问题","titles":["软件分析"]},"13":{"title":"数据流分析","titles":[]},"14":{"title":"Fuzzing 基础","titles":[]},"15":{"title":"Coverage","titles":["Fuzzing 基础"]},"16":{"title":"Mutation-Based Fuzzing","titles":["Fuzzing 基础"]},"17":{"title":"静态单赋值和稀疏分析","titles":[]},"18":{"title":"SSA 转换","titles":["静态单赋值和稀疏分析"]}},"dirtCount":0,"index":[["作为参数更新进去",{"2":{"18":1}}],["作为工程师",{"2":{"12":1}}],["位于栈顶",{"2":{"18":1}}],["遍历所有的",{"2":{"18":1}}],["遍历所有的节点",{"2":{"18":1}}],["函数的参数还不能够确定",{"2":{"18":1}}],["函数",{"2":{"18":2}}],["根据",{"2":{"18":1}}],["关系",{"2":{"18":2}}],["对程序进行",{"2":{"18":1}}],["对于当前内",{"2":{"18":1}}],["对于内存漏洞",{"2":{"14":1}}],["对于此类算法",{"2":{"13":1}}],["对于诸如停机问题这样的判断问题",{"2":{"12":1}}],["对于动态改变大小的哈希表",{"2":{"9":1}}],["上的算法都不完全正确",{"2":{"18":1}}],["虎书",{"2":{"18":1}}],["生成时非常有感触",{"2":{"18":1}}],["形式是一个比较复杂的流程",{"2":{"18":1}}],["形式中",{"2":{"17":1}}],["转换整体的流程可以大致总结为以下几个步骤",{"2":{"18":1}}],["转换代码给放过来",{"2":{"18":1}}],["转换",{"0":{"18":1}}],["所以数据流分析和优化算法都会变得更加简单",{"2":{"17":1}}],["所谓",{"2":{"14":1}}],["每个变量在代码中只有一次赋值",{"2":{"17":1}}],["每一层都会独立消耗时间",{"2":{"6":1}}],["分析",{"2":{"17":1,"18":1}}],["更加便于对程序进行优化",{"2":{"17":1}}],["此时",{"2":{"18":1}}],["此外",{"2":{"17":1}}],["此类算法具有一些共同的特质",{"2":{"13":1}}],["use",{"2":{"17":1}}],["许多数据流分析都需要追踪某个变量的定义和使用",{"2":{"17":1}}],["许多现实中的问题并不可能做到100",{"2":{"12":1}}],["静态单赋值和稀疏分析",{"0":{"17":1},"1":{"18":1}}],["尽管数量一样",{"2":{"15":1}}],["和老师",{"2":{"18":1}}],["和",{"2":{"15":1}}],["和状态之间的转移",{"2":{"13":1}}],["然而这样一来我们就忽略了",{"2":{"15":1}}],["然后尝试证明",{"2":{"7":1}}],["时",{"2":{"15":1}}],["时间消耗由",{"2":{"8":2}}],["时间复杂度",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1}}],["后者则是面向这样一种场景",{"2":{"15":1}}],["属于是最直观的覆盖率",{"2":{"15":1}}],["前者即跑的代码越多越好",{"2":{"15":1}}],["slide",{"2":{"18":1}}],["ssa",{"0":{"18":1},"2":{"17":1,"18":2}}],["single",{"2":{"17":1}}],["static",{"2":{"17":1}}],["statement",{"2":{"15":3}}],["something",{"2":{"15":4}}],["sanitizer",{"2":{"14":1}}],["sa",{"2":{"13":1}}],["测量代码覆盖率在多数情况下是一种简单而完全自动化的方法",{"2":{"15":1}}],["测试执行以及测试结果检查这整个流程",{"2":{"14":1}}],["测试是必要的一环",{"2":{"14":1}}],["帮助我们识别漏洞的工具",{"2":{"14":1}}],["内存访问错误",{"2":{"14":1}}],["通过测试程序在随机输入下的行为",{"2":{"14":1}}],["robustness",{"2":{"14":1}}],["root",{"2":{"8":1}}],["以控制流向量",{"2":{"15":1}}],["以测试程序的健壮性",{"2":{"14":1}}],["以及指导测试样例的生成",{"2":{"15":1}}],["以及",{"2":{"13":1,"15":2}}],["技术",{"2":{"14":1}}],["包括测试样例生成",{"2":{"14":1}}],["想要更好地进行测试就必须要将测试的各个步骤全都进行自动化",{"2":{"14":1}}],["说明你需要将它自动化",{"2":{"14":1}}],["手动进行测试是一种灵活的测试方法",{"2":{"14":1}}],["动态测试的方法也是漏洞猎手们的主力工具",{"2":{"14":1}}],["尤其是内存漏洞的挖掘领域",{"2":{"14":1}}],["来检测其是否能正常工作",{"2":{"14":1}}],["基础",{"0":{"14":1},"1":{"15":1,"16":1}}],["基于有限状态自动机的抽象来判断停机问题的算法被称为模型检查技术",{"2":{"11":1}}],["03",{"2":{"13":1}}],["0≤cg",{"2":{"3":1}}],["0≤f",{"2":{"2":1}}],["ir",{"2":{"18":1}}],["i",{"2":{"13":1}}],["io",{"2":{"13":1}}],["if",{"2":{"11":1,"15":1}}],["xiongyingfei",{"2":{"13":1}}],["wiki",{"2":{"13":1}}],["wikipedia",{"2":{"13":1}}],["en",{"2":{"13":1}}],["https",{"2":{"13":2}}],["详见",{"2":{"13":1}}],["引擎的实现",{"2":{"13":1}}],["有许多种不同的覆盖率",{"2":{"15":1}}],["有许多不同的",{"2":{"13":1}}],["有了模型后",{"2":{"12":1}}],["具体请参考相关资料",{"2":{"13":1}}],["终止性和收敛性都可以使用一套名为数据流分析单调框架的数学模型进行证明",{"2":{"13":1}}],["直接崩溃等等",{"2":{"14":1}}],["直接求平均值",{"2":{"10":1}}],["直到没有任何结点的值发生更新",{"2":{"13":1}}],["处理它们的结点",{"2":{"13":1}}],["认为所有分支都有可能到达",{"2":{"13":1}}],["认为所有的分支都有可能到达",{"2":{"13":1}}],["忽略掉程序的条件判断",{"2":{"13":1}}],["近似方案2",{"2":{"13":1}}],["近似方案1",{"2":{"13":1}}],["近似法的原则是",{"2":{"12":1}}],["phi",{"2":{"18":3}}],["python1",{"2":{"15":1}}],["pdf",{"2":{"13":1}}],["plane",{"2":{"13":2}}],["potential",{"2":{"10":1}}],["两部分",{"2":{"13":1}}],["两者平手",{"2":{"8":1}}],["控制",{"2":{"13":1}}],["数据",{"2":{"13":1}}],["数据流分析",{"0":{"13":1}}],["搜索",{"2":{"12":1}}],["抽象",{"2":{"12":1}}],["就把变量当前的最新副本",{"2":{"18":1}}],["就在节点开头为这个变量插入一个相应的",{"2":{"18":1}}],["就遍历该节点的",{"2":{"18":1}}],["就是一个非常关键的",{"2":{"14":1}}],["就属于数据流分析的算法",{"2":{"13":1}}],["就像路由系统的",{"2":{"13":1}}],["就输出不知道",{"2":{"12":1}}],["就可以判定这台计算机上的所有程序停机问题",{"2":{"11":1}}],["就可以证明总摊还代价是总实际代价的上界",{"2":{"10":2}}],["就可以分出以下三种情况",{"2":{"8":1}}],["又比如",{"2":{"12":1}}],["槑",{"2":{"12":1}}],["负和不确定",{"2":{"12":1}}],["零",{"2":{"12":1}}],["比如最常用的",{"2":{"15":1}}],["比如抛出未捕获的异常",{"2":{"14":1}}],["比如都是不断循环直到某轮的状态不再更新时停止",{"2":{"13":1}}],["比如",{"2":{"12":1,"13":1}}],["少输出一点",{"2":{"12":1}}],["否",{"2":{"12":1}}],["判定算法最好多输出一些",{"2":{"12":1}}],["当然",{"2":{"12":1,"18":1}}],["我不知道",{"2":{"12":2}}],["我们还可以将程序转化为静态单赋值形式",{"2":{"17":1}}],["我们需要",{"2":{"15":1}}],["我们需要通过动态运行程序",{"2":{"14":1}}],["我们往往会测量测试中程序的哪一部分被实际执行了",{"2":{"15":1}}],["我们会在算法中一视同仁地处理两个分支",{"2":{"13":1}}],["我们重点关注数据流分析如何处理条件分支和循环语句",{"2":{"13":1}}],["我们暂时不考虑分析的目标",{"2":{"13":1}}],["我们很难知道状态会如何转移",{"2":{"13":1}}],["我们都知道近似法的重要性",{"2":{"12":1}}],["我们使用的计算机受到物理条件的限制",{"2":{"11":1}}],["我们可以捕捉到各种非预期的行为",{"2":{"14":1}}],["我们可以允许判定算法输出",{"2":{"12":1}}],["我们可以从两个角度来思考这个问题",{"2":{"11":1}}],["我们可以将",{"2":{"6":1}}],["我们就可以使用摊还分析证明其平均操作时间为",{"2":{"9":1}}],["我们也可以证明平均操作的时间开销并不大",{"2":{"9":1}}],["我们有时需要计算对于某个数据结构的一系列操作的平均时间",{"2":{"9":1}}],["我们在计算递归算法的时间复杂度时",{"2":{"5":1}}],["我们主要关注的是",{"2":{"4":1}}],["我们采用渐进分析",{"2":{"0":1}}],["我们希望能够衡量一个算法的复杂度",{"2":{"0":1}}],["非判定问题",{"0":{"12":1}}],["模型检查技术几乎无法应用于大型软件",{"2":{"11":1}}],["超出了检查程序的可处理范围",{"2":{"11":1}}],["状态数太多",{"2":{"11":1}}],["由于编译教材",{"2":{"18":1}}],["由于每个变量都只有一次赋值",{"2":{"17":1}}],["由于状态爆炸",{"2":{"11":1}}],["由于实际上判断这种问题的程序本身需要比问题中更多的状态数量",{"2":{"11":1}}],["被广泛应用于硬件领域",{"2":{"11":1}}],["也就是没有执行",{"2":{"15":1}}],["也就是停机问题证明中的例子",{"2":{"11":1}}],["也就是判断计算机程序是否会按照预期进行工作而没有缺陷",{"2":{"11":1}}],["这一点笔者在写编译器的",{"2":{"18":1}}],["这个赋值在实际运行中可能会跑很多遍",{"2":{"17":1}}],["这个模型设计到的数据较为复杂",{"2":{"13":1}}],["这组样例集就可以达到最高的覆盖率",{"2":{"15":1}}],["这就是代码覆盖率的概念",{"2":{"15":1}}],["这种做法就叫做数据流分析",{"2":{"13":1}}],["这意味着程序有可能回到同一个状态",{"2":{"11":1}}],["这样",{"2":{"9":1}}],["其核心在与生成随机的测试样例",{"2":{"14":1}}],["其行为是否能符合我们的预期",{"2":{"14":1}}],["其安全性",{"2":{"13":1}}],["其状态数量是有限的",{"2":{"11":1}}],["其与实际代价的差值会增减初始值为0的信用",{"2":{"10":1}}],["但后者包含的信息更多",{"2":{"15":1}}],["但是我们静态分析只关心代码",{"2":{"17":1}}],["但是根据著名的不知出自哪里的自动化原则",{"2":{"14":1}}],["但是对于不同的问题",{"2":{"10":1}}],["但一个近似的答案已经足够有用",{"2":{"12":1}}],["但在软件领域中",{"2":{"11":1}}],["但现实情况似乎好一些",{"2":{"11":1}}],["理论如此悲观",{"2":{"11":1}}],["不在路径末尾做合并",{"2":{"13":1}}],["不能处理好的就输出不知道",{"2":{"12":1}}],["不过",{"2":{"11":1}}],["不严谨地说",{"2":{"11":1}}],["不存在一个可以判断某个程序是否能够跑完的算法",{"2":{"11":1}}],["莱斯定理告诉我们",{"2":{"11":1}}],["确定程序有无内存泄露同样是不可判定问题",{"2":{"11":1}}],["类似也可以证明没有一个算法能够判断一个软件存在某种缺陷",{"2":{"11":1}}],["悖论",{"2":{"11":1}}],["反证法",{"2":{"11":1}}],["停机问题是不可判定问题",{"2":{"11":1}}],["停机问题",{"2":{"11":1}}],["则我们永远无法分析程序",{"2":{"11":1}}],["则有",{"2":{"8":3}}],["将每个变量更新成新的变量名",{"2":{"18":1}}],["将一个普通的程序转化为",{"2":{"18":1}}],["将所有的操作数都抽象为正",{"2":{"12":1}}],["将所有操作的开销加起来",{"2":{"10":1}}],["将能处理好的处理好",{"2":{"12":1}}],["将其记为",{"2":{"11":1}}],["计算出每个节点的",{"2":{"18":1}}],["计算节点之间的",{"2":{"18":1}}],["计算机程序可以表示自然数和四则运算",{"2":{"11":1}}],["计算递归函数的时间消耗",{"0":{"5":1},"1":{"6":1,"7":1,"8":1}}],["哥德尔不完备性定理",{"2":{"11":1}}],["可以证明",{"2":{"11":1}}],["可以彻底避免某个软件出现缺陷吗",{"2":{"11":1}}],["可以使用一些特殊的方法",{"2":{"5":1}}],["是",{"2":{"12":1}}],["是否会存在缺陷",{"2":{"11":1}}],["是一个十分重要的议题",{"2":{"11":1}}],["是因为它将递归函数的时间复杂度计算分成了三种情况",{"2":{"8":1}}],["重要服务都由计算机程序所负责",{"2":{"11":1}}],["越来越多的基础服务",{"2":{"11":1}}],["随着计算机在人类社会中的普及",{"2":{"11":1}}],["软件分析的两大部分就是近似法的两个步骤",{"2":{"12":1}}],["软件分析存在终极的解法",{"2":{"11":1}}],["软件分析",{"0":{"11":1},"1":{"12":1},"2":{"11":1}}],["下",{"2":{"10":1}}],["遞迴",{"2":{"10":1}}],["時間複雜度",{"2":{"10":1}}],["参考资料",{"2":{"10":1,"13":1}}],["≥φ",{"2":{"10":1}}],["def",{"2":{"17":1}}],["dominance",{"2":{"18":4}}],["do",{"2":{"15":4}}],["dataflow",{"2":{"13":1}}],["datalog",{"2":{"13":3}}],["data",{"2":{"13":1}}],["d0",{"2":{"10":1}}],["dn",{"2":{"10":1}}],["di−1",{"2":{"10":1}}],["di",{"2":{"10":2}}],["−φ",{"2":{"10":1}}],["并添加到每个变量的栈中",{"2":{"18":1}}],["并在每轮中不断对每个结点做交汇运算来更新其值",{"2":{"13":1}}],["并检查其中是否存在环",{"2":{"11":1}}],["并基于势能函数定义摊还代价",{"2":{"10":1}}],["并忽略那些和计算机本身相关的参数",{"2":{"0":1}}],["φ",{"2":{"10":2}}],["构造一个将状态映射到势能值的势能函数",{"2":{"10":1}}],["取数据结构的某些特征为参数",{"2":{"10":1}}],["势能法",{"2":{"10":1}}],["只考虑数据流分析的算法",{"2":{"13":1}}],["只关注数据的变化",{"2":{"13":1}}],["只关注抽象的算法性能",{"2":{"0":1}}],["只要我们能够识别出相应的表现",{"2":{"14":1}}],["只要我们证明有",{"2":{"10":1}}],["只要我们证明信用总是大于0",{"2":{"10":1}}],["只要将程序抽象为一个有限状态的自动机",{"2":{"11":1}}],["核算法",{"2":{"10":1}}],["聚合分析",{"2":{"10":1}}],["最简单的方法",{"2":{"10":1}}],["一条语句指向另一条语句",{"2":{"15":1}}],["一定会存在一种最适合",{"2":{"10":1}}],["一个变量可能会被赋值很多次",{"2":{"17":1}}],["一个程序可以以看成是状态",{"2":{"13":1}}],["一个理论计算机程序的任何性质都是不可判定的",{"2":{"11":1}}],["一个最高为",{"2":{"7":1}}],["一个显然的定理",{"2":{"4":1}}],["三种方法往往都是可用的",{"2":{"10":1}}],["而直接执行了",{"2":{"15":1}}],["而且在指导测试样例生成中扮演着至关重要的地位",{"2":{"15":1}}],["而不是语句本身来计算测试的覆盖率",{"2":{"15":1}}],["而不是",{"2":{"9":1}}],["而树一共有",{"2":{"6":1}}],["即使一个数据结构的某种操作十分耗时",{"2":{"9":1}}],["摊还分析的三种方法",{"0":{"10":1}}],["摊还分析",{"0":{"9":1}}],["2022",{"2":{"13":1}}],["2",{"2":{"8":1,"15":4}}],["2n",{"2":{"5":1,"6":2}}],["1",{"2":{"8":1,"9":1,"15":3}}],["1然后我们比较",{"2":{"8":1}}],["与上面所叙述的三种情况对应",{"2":{"8":1}}],["与",{"2":{"8":1}}],["block",{"2":{"18":2}}],["basic",{"2":{"18":2}}],["based",{"0":{"16":1}}],["branch",{"2":{"15":3}}],["bug",{"2":{"11":1}}],["b",{"2":{"8":2,"15":2}}],["bound",{"2":{"4":1}}],["首先要把",{"2":{"8":1}}],["为了判断某个测试的有效程度",{"2":{"15":1}}],["为了判断究竟属于哪一种情况",{"2":{"8":1}}],["为不同的操作赋予一个摊还代价",{"2":{"10":1}}],["为未知数的多项式",{"2":{"7":2}}],["主导",{"2":{"8":2}}],["主要观察两点",{"2":{"6":1}}],["liveout",{"2":{"18":1}}],["liveness",{"2":{"18":1}}],["liveliness",{"2":{"13":1}}],["llvm",{"2":{"18":1}}],["leaf",{"2":{"8":1}}],["log3",{"2":{"6":1}}],["递归树的每一次递归合并开销大",{"2":{"8":1}}],["递归树分支和每一次递归的开销类似",{"2":{"8":1}}],["递归树分支极多",{"2":{"8":1}}],["递归函数并不像非递归函数那样直观",{"2":{"5":1}}],["要叫这个名字",{"2":{"8":1}}],["之所以",{"2":{"8":1}}],["秒杀递归函数",{"0":{"8":1}}],["次的以",{"2":{"7":1}}],["次的一个以",{"2":{"7":1}}],["mutation",{"0":{"16":1}}],["method",{"2":{"10":2}}],["master",{"0":{"8":1},"2":{"8":1,"10":1}}],["m",{"2":{"7":2}}],["或是最高为",{"2":{"7":1}}],["假设",{"2":{"7":1}}],["那么可以",{"2":{"7":1}}],["使用这些域的运算来判断",{"2":{"12":1}}],["使用",{"0":{"8":1}}],["使用代入法证明猜测",{"0":{"7":1}}],["使用迭代法猜测复杂度",{"0":{"6":1}}],["层",{"2":{"6":1}}],["中",{"2":{"6":1}}],["例如",{"2":{"6":1,"9":1}}],["树一共有多少层",{"2":{"6":1}}],["树的每一层会消耗多少时间",{"2":{"6":1}}],["的后继",{"2":{"18":1}}],["的全覆盖率分别为",{"2":{"15":1}}],["的情况",{"2":{"15":1}}],["的样例",{"2":{"15":1}}],["的逻辑语言来简洁地实现",{"2":{"13":1}}],["的结果",{"2":{"12":1}}],["的完美解决",{"2":{"12":1}}],["的问题",{"2":{"11":1}}],["的表达式使用树形展开",{"2":{"6":1}}],["的方法",{"2":{"0":1}}],["+f",{"2":{"8":1}}],["+n",{"2":{"5":1,"6":1}}],["+t",{"2":{"5":1,"6":1}}],["3",{"2":{"5":2,"6":2,"8":1,"15":4}}],["如何判断具体问题",{"2":{"12":1}}],["如何把具体的程序抽象成可以处理的模型",{"2":{"12":1}}],["如果其开头有相应的",{"2":{"18":1}}],["如果遍历的节点有对于该变量的引用或",{"2":{"18":1}}],["如果节点有对于某个变量的定义",{"2":{"18":1}}],["如果在样例集中有一个满足",{"2":{"15":1}}],["如果你重复做了某件事三遍及以上",{"2":{"14":1}}],["如果",{"2":{"8":3}}],["如果猜测",{"2":{"7":1}}],["如",{"2":{"5":1}}],["需要先得到递归函数的时间消耗表达式",{"2":{"5":1}}],["在程序中",{"2":{"17":1}}],["在上面的例子中",{"2":{"15":1}}],["在这种情况下",{"2":{"15":1}}],["在这几种表示法中",{"2":{"4":1}}],["在计算",{"2":{"15":1}}],["在漏洞挖掘领域",{"2":{"14":1}}],["在软件开发的领域",{"2":{"14":1}}],["在控制流汇合的所有位置提前做合并",{"2":{"13":1}}],["在静态分析程序时",{"2":{"13":1}}],["在搜索时如果超时",{"2":{"12":1}}],["在判定计算结果的正负时",{"2":{"12":1}}],["在",{"2":{"6":1,"17":1}}],["在使用以下方法之前",{"2":{"5":1}}],["⟺θ",{"2":{"4":1}}],["⟺∃",{"2":{"2":1,"3":1,"4":1}}],["变化",{"2":{"4":1}}],["常数项是可以直接扔掉的",{"2":{"4":1}}],["θ",{"0":{"4":2}}],["≤",{"2":{"7":1}}],["≤ckm",{"2":{"7":1}}],["≤c2g",{"2":{"4":1}}],["≤cg",{"2":{"2":1}}],["≤f",{"2":{"3":1,"4":1}}],["==",{"2":{"15":2}}],["=θ",{"2":{"8":4}}],["=at",{"2":{"8":1}}],["=t",{"2":{"5":1,"6":1}}],["=ω",{"2":{"3":1,"8":1}}],["=o",{"2":{"2":1,"4":1,"7":1,"8":1}}],["ω",{"0":{"3":2},"2":{"4":1}}],["∀",{"2":{"2":1,"3":1,"4":1}}],["k",{"2":{"2":1,"3":1,"4":1,"7":2}}],["chain",{"2":{"17":1}}],["cond",{"2":{"15":3}}],["control",{"2":{"13":1}}],["coverage",{"0":{"15":1},"2":{"15":6}}],["ci^=ci+φ",{"2":{"10":1}}],["case",{"2":{"8":3}}],["c2",{"2":{"4":1}}],["c1g",{"2":{"4":1}}],["c1",{"2":{"4":1}}],["c",{"2":{"2":1,"3":1}}],["github",{"2":{"13":1}}],["gt",{"2":{"8":1}}],["g",{"2":{"2":1,"3":1,"4":1}}],["frontier",{"2":{"18":2}}],["form",{"2":{"17":1}}],["false",{"2":{"15":1}}],["fuzzing",{"0":{"14":1,"16":1},"1":{"15":1,"16":1},"2":{"14":1}}],["f",{"2":{"2":1,"3":1,"4":1,"8":5}}],["定义为",{"2":{"2":1,"3":1,"4":1}}],["表示成下面这种形式",{"2":{"8":1}}],["表示函数的",{"2":{"4":1}}],["表示函数的下界",{"2":{"3":1}}],["表示函数的上界",{"2":{"2":1}}],["表示法",{"0":{"2":1,"3":1,"4":1}}],["org",{"2":{"13":1}}],["o",{"0":{"2":2},"2":{"4":1,"6":1,"9":2}}],["大量的静态分析可以通过一种叫做",{"2":{"13":1}}],["大",{"0":{"2":1,"3":1,"4":1}}],["渐进分析的几种标记",{"0":{"1":1},"1":{"2":1,"3":1,"4":1}}],["会如何变化",{"2":{"0":1}}],["true",{"2":{"15":1}}],["theorem",{"0":{"8":1},"2":{"8":1,"10":1}}],["tight",{"2":{"4":1}}],["t",{"2":{"0":1,"5":1,"6":2,"7":3,"8":5,"11":2}}],["算法所需时间",{"2":{"0":1}}],["趋向于无穷大时",{"2":{"0":1}}],["n2",{"2":{"9":1}}],["nlogba+ϵ",{"2":{"8":1}}],["nlogbalgn",{"2":{"8":1}}],["nlogba−ϵ",{"2":{"8":1}}],["nlogba",{"2":{"8":3}}],["nlogn",{"2":{"6":1}}],["nm",{"2":{"7":1}}],["n≥k",{"2":{"2":1,"3":1,"4":1}}],["n",{"0":{"2":1,"3":1,"4":1},"2":{"0":2,"2":4,"3":4,"4":5,"5":2,"6":4,"7":3,"8":12}}],["考虑当问题的输入规模",{"2":{"0":1}}],["assignment",{"2":{"17":1}}],["asymptotic",{"2":{"0":1}}],["a",{"2":{"15":2}}],["address",{"2":{"14":1}}],["accounting",{"2":{"10":1}}],["aggregate",{"2":{"10":1}}],["a≥1",{"2":{"8":1}}],["amp",{"2":{"4":1}}],["analysis",{"2":{"0":1,"10":1,"13":2}}],["因此等有时间了会把自己写的",{"2":{"18":1}}],["因此才叫做静态单赋值形式",{"2":{"17":1}}],["因此我们往往会先计算程序的",{"2":{"17":1}}],["因此可以在分析时直接忽略状态转移的条件",{"2":{"13":1}}],["因此可以猜测时间复杂度为",{"2":{"6":1}}],["因此一个程序还是没办法判断自己是否会停机",{"2":{"11":1}}],["因此一定包含一个无法证明的定理",{"2":{"11":1}}],["因此",{"2":{"0":1,"13":1}}]],"serializationVersion":2}';export{t as default};
